"use strict";(self.webpackChunkradicle_docs=self.webpackChunkradicle_docs||[]).push([[113],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(n),m=a,u=h["".concat(l,".").concat(m)]||h[m]||c[m]||r;return n?i.createElement(u,o(o({ref:t},d),{},{components:n})):i.createElement(u,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6740:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],s={id:"how-it-works",title:"How it Works"},l=void 0,p={unversionedId:"understanding-radicle/how-it-works",id:"understanding-radicle/how-it-works",title:"How it Works",description:"Radicle Link is the peer-to-peer gossip protocol that powers the Radicle",source:"@site/docs/understanding-radicle/how-it-works.md",sourceDirName:"understanding-radicle",slug:"/understanding-radicle/how-it-works",permalink:"/understanding-radicle/how-it-works",editUrl:"https://github.com/radicle-dev/radicle-docs/blob/master/docs/understanding-radicle/how-it-works.md",tags:[],version:"current",frontMatter:{id:"how-it-works",title:"How it Works"},sidebar:"docsSidebar",previous:{title:"Why Radicle?",permalink:"/understanding-radicle/why-radicle"},next:{title:"Radicle versus GitHub and GitLab",permalink:"/understanding-radicle/radicle-versus-github-gitlab"}},d={},c=[{value:"Overview",id:"overview",level:2},{value:"Identities",id:"identities",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Data Model",id:"data-model",level:3},{value:"Doc Payload",id:"doc-payload",level:3},{value:"Radicle URNs",id:"radicle-urns",level:3},{value:"Delegations",id:"delegations",level:3},{value:"Verification",id:"verification",level:3},{value:"Git Implementation",id:"git-implementation",level:2},{value:"Overview",id:"overview-2",level:3},{value:"Namespacing",id:"namespacing",level:3},{value:"Git Encoding",id:"git-encoding",level:3},{value:"Fetching",id:"fetching",level:3},{value:"Working Copies",id:"working-copies",level:3},{value:"Peer Discovery &amp; Replication",id:"peer-discovery--replication",level:2},{value:"Overview",id:"overview-3",level:3},{value:"Replication Model",id:"replication-model",level:3},{value:"Tracking",id:"tracking",level:3},{value:"Direct Tracking",id:"direct-tracking",level:4},{value:"The Social Graph",id:"the-social-graph",level:4},{value:"Validation",id:"validation",level:3},{value:"Seeding",id:"seeding",level:3},{value:"Collaboration Model",id:"collaboration-model",level:2}],h={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Radicle Link is the peer-to-peer gossip protocol that powers the Radicle\nnetwork. This documentation will provide an overview on how the protocol works.\nMore information \u2014 including specifications, security considerations, and\nimplementation notes \u2014 can be found in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/radicle-dev/radicle-link"},"corresponding repository"),"."),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Radicle Link is a peer-to-peer gossip protocol with a generic distributed\nversion control backend. It aims to be general enough to be used on top of\nsystems such as pijul or mercurial, though it's initial implementation is\nfocused on supporting Git."),(0,r.kt)("p",null,"The protocol disseminates Git repositories via gossip-based replication,\nenabling the hosting and sharing of repositories without reliance on central\nservers. Repositories on the Radicle network are called 'projects', which are\ngossiped by 'peers'."),(0,r.kt)("p",null,"In Radicle:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Peers track other peers"),(0,r.kt)("li",{parentName:"ul"},"Peers track projects they are interested in"),(0,r.kt)("li",{parentName:"ul"},"Peers gossip about projects. This means replicating updates from the peers\nthey track and the projects they are interested in")),(0,r.kt)("p",null,'These interactions create a "trusted" social graph of peers and projects that\nbecome the foundation for collaboration within Radicle.'),(0,r.kt)("p",null,"Radicle Link supports a bazaar-style collaboration model in which there is no\nsingle canonical 'master' branch that contributors merge into, but a multitude\nof upstreams exchanging patches via remotes."),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"DISCLAIMER \ud83c\udf31")),(0,r.kt)("br",null),(0,r.kt)("p",null,(0,r.kt)("em",null,"While this documentation reflects the specification of the Radicle Link protocol, not all information is integrated into the Beta release"))),(0,r.kt)("h2",{id:"identities"},"Identities"),(0,r.kt)("h3",{id:"overview-1"},"Overview"),(0,r.kt)("p",null,"Radicle Link distinguishes two types of identities: personal and project. The\nfirst describes an actor (a ",(0,r.kt)("inlineCode",{parentName:"p"},"peer"),") in the system, while the second describes a\nsoftware project (repository) on which one or more actors collaborate."),(0,r.kt)("p",null,'The notion of "identity" in Radicle Link simply means the presence of an\nidentity document at a conventional location within a Git repository, where the\ndocument is subject to certain verification rules. The hash of the initial\ndocument is considered its stable identifier and encoded as a uniform resource\nname (URN) of the form ',(0,r.kt)("inlineCode",{parentName:"p"},"rad:git:$HASH")," (for Git repositories). The URN is\nsupposed to be resolvable on the network into a top-level Git repository of the\nsame name ($HASH.git), which is valid if it contains said identity document, and\nthe document passes the verification rules."),(0,r.kt)("h3",{id:"data-model"},"Data Model"),(0,r.kt)("p",null,"Our model for maintaining consistency on repository data, is based on The Update\nFramework (",(0,r.kt)("a",{parentName:"p",href:"https://theupdateframework.io/"},"TUF"),"), which was conceived as a means of securely distributing\nsoftware packages. Our approach is to establish an ownership proof, tied to the\nnetwork identity of a peer (",(0,r.kt)("inlineCode",{parentName:"p"},"PeerId")," - See ",(0,r.kt)("a",{parentName:"p",href:"#key-architecture"},"Key Architecture"),'), or a set of\npeers, such that the views of a project can be replicated according to the trust\nrelationships between peers ("tracking").'),(0,r.kt)("p",null,"The identity of a project (repository) or peer is established using a document\nof the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct Doc<T, D> {\n    replaces: Option<Revision>,\n    payload: T,\n    delegations: D,\n}\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Revision")," is a cryptographic hash of a document's contents, such that this\ndocument is content-addressable by this hash within the storage system.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"replaces")," refers to the previous revision of the document, or none if it is\nthe first revision.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"payload")," is an extensible, forwards- and backwards-compatible datatype\ncontaining application-defined metadata about the repository. The protocol\ninterprets some of the properties, as described in ",(0,r.kt)("a",{parentName:"p",href:"#doc-payload"},"Doc Payload"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"delegations")," contains the public keys of key owners who are authorised to\nissue and approve new revisions of the document. The delegation format depends\non the type of identity being established, as detailed below."))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Doc")," must be serialised in canonical form. See more in ",(0,r.kt)("a",{parentName:"p",href:"#serialisation"},"Serialisation"),"."),(0,r.kt)("p",null,"The authenticity of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Doc")," is captured by the following type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct Identity<T, D> {\n    id: ContentId,\n    root: Revision,\n    revision: Revision,\n    doc: Doc<T, D>,\n    signatures: HashMap<PublicKey, Signature>,\n}\n\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"*`id` is the content-addressable hash of the Identity itself\n*`root` is the initial revision of the identity Doc\n*`revision` is the current revision of the identity Doc\n*`doc` is the Doc described by revision\n*`signatures` contains signatures over the document history, indexed by the\npublic keys used. A signature is made over the cryptographic hash of the\nconcatenation of the Revisions chain, from most recent to the root.\n")),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity")," describes the attestation of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Doc"),"s validity and the ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," of a\nverified ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity")," is the stable identifier of the repository."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Read more in the ",(0,r.kt)("a",{parentName:"em",href:"https://github.com/radicle-dev/radicle-link/blob/9e1cfdf8bbb77a31f9a4c39352cf6faea220afc2/docs/spec/identities.md"},"specification"))),(0,r.kt)("h3",{id:"doc-payload"},"Doc Payload"),(0,r.kt)("p",null,"The doc payload determines the type of identity: personal or project. The\npayload must include one of the following structures (but not both) for\ninterpretation by the protocol:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'struct User {\n    /// A short name (nickname, handle), without any prefix such as the `@`\n    /// character\n    name: String,\n}\n\nstruct Project {\n    /// A short name\n    name: String,\n\n    /// A slightly longer description (should fit in a headline)\n    description: Option<String>,\n\n    /// The default branch. "master" is assumed for git repositories if\n    /// unspecified.\n    default_branch: Option<String>,\n}\n\n')),(0,r.kt)("p",null,"There are currently no restrictions on the length (in bytes) of the fields.\nApplications may add additional payload data, but must do so in a way which\nunambiguously preserves the shape of the above definitions. See\n",(0,r.kt)("a",{parentName:"p",href:"#serialisation"},"Serialisation"),"."),(0,r.kt)("h3",{id:"radicle-urns"},"Radicle URNs"),(0,r.kt)("p",null,"Identities are addressable within the Radicle Network by their stable\nidentifier, encoded as a URN. Radicle URNs are syntactically and functionally\nequivalent to URNs as per ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc8141"},"RFC8141"),"."),(0,r.kt)("p",null,"The syntax of a Radicle URN is defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'"rad" ":" protocol ":" root [ "/" path ]\n\n')),(0,r.kt)("p",null,"where:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'protocol = "git"\nroot     = MULTIBASE(MULTIHASH(id))\npath     = pct-encoded\nid       = BYTES\n\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," is the ",(0,r.kt)("inlineCode",{parentName:"p"},"root")," field of a verified Identity, as specified previously.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"MULTIBASE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MULTIHASH")," encodings are specified in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/multiformats/multibase"},"multibase")," and\n",(0,r.kt)("a",{parentName:"p",href:"https://multiformats.io/multihash/"},"multihash"),", respectively. The preferred alphabet for the multibase encoding\nis ",(0,r.kt)("a",{parentName:"p",href:"http://philzimmermann.com/docs/human-oriented-base-32-encoding.txt"},"z-base32"),". pct-encoded is defined in ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc3986"},"RFC3986"),", and the equivalence\nrules as per ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc8141"},"RFC8141")," apply."),(0,r.kt)("p",null,"An example of a Radicle URN:\n",(0,r.kt)("inlineCode",{parentName:"p"},"rad:git:hnrkmzko1nps1pjogxadcmqipfxpeqn6xbeto"),"."),(0,r.kt)("h3",{id:"delegations"},"Delegations"),(0,r.kt)("p",null,"As described in ",(0,r.kt)("a",{parentName:"p",href:"#data-model"},"Data Model")," Radicle Link distinguishes two types of\nidentities: personal and project. The first describes a person (usually denoted\nas a ",(0,r.kt)("inlineCode",{parentName:"p"},"peer"),") in the system, while the second describes a software project\n(repository) on which one or more persons collaborate. Apart from their\n",(0,r.kt)("a",{parentName:"p",href:"#doc-payload"},"payload")," types ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", they differ in their delegations type ",(0,r.kt)("inlineCode",{parentName:"p"},"D"),":"),(0,r.kt)("p",null,"Personal identities can only delegate to anonymous keys, while project\nidentities may attach a personal identity to a key delegation. More formally:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"type User<T> = Identity<T, HashSet<PublicKey>>;\n\nenum ProjectDelegation<U> {\n    Key(PublicKey),\n    User(User<U>),\n}\n\ntype Project<T, U> = Identity<T, ProjectDelegation<U>>;\n\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"delegations")," of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Project")," are also referred to as the project's\n",(0,r.kt)("strong",{parentName:"p"},"maintainers"),"."),(0,r.kt)("p",null,"These delegations are used to verify the authenticity of data across the\nnetwork. See more notes on Verification ",(0,r.kt)("a",{parentName:"p",href:"#verification"},"here"),"."),(0,r.kt)("h3",{id:"verification"},"Verification"),(0,r.kt)("p",null,"Document revisions, as well as authenticity attestations, form a hash-linked\nchain leading to the initial revision of the document. In order to verify the\nauthenticity of a given identity attestation (",(0,r.kt)("inlineCode",{parentName:"p"},"Identity"),"), the chain of updates\nmust be contiguous and subject to the following verification rules."),(0,r.kt)("p",null,"There are four levels of validity:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Untrusted")),(0,r.kt)("p",{parentName:"li"},"The identity document is well-formed, and points to a root object which is\nretrievable from local storage.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Signed")),(0,r.kt)("p",{parentName:"li"},"The identity carrier passes ",(0,r.kt)("strong",{parentName:"p"},"1."),", and is signed by at least one key\nspecified in the delegations of the document.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Quorum")),(0,r.kt)("p",{parentName:"li"},"The identity carrier passes ",(0,r.kt)("strong",{parentName:"p"},"2."),", and is signed by a quorum of the keys\nspecified in the delegations of the document (",(0,r.kt)("inlineCode",{parentName:"p"},"Q > D/2"),").")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Verified")),(0,r.kt)("p",{parentName:"li"},"The identity carrier passes ",(0,r.kt)("strong",{parentName:"p"},"3."),", and: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The document does not refer to a previous revision, and no previous revision is known "),(0,r.kt)("li",{parentName:"ul"},"Or, the set of signatures forms a quorum of the ",(0,r.kt)("a",{parentName:"li",href:"#delegations"},"delegations")," of the previous revision.")),(0,r.kt)("p",{parentName:"li"},"It is an error if: "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"No previous revision is given, but a parent in the identity attestation chain is found"),(0,r.kt)("li",{parentName:"ul"},"A previous revision is given, but the identity attestation chain does not yield a parent"),(0,r.kt)("li",{parentName:"ul"},"A previous revision is given, but it is not the same the parent attestation refers to"),(0,r.kt)("li",{parentName:"ul"},"The current and parent attestations refer to different roots")))),(0,r.kt)("h2",{id:"git-implementation"},"Git Implementation"),(0,r.kt)("h3",{id:"overview-2"},"Overview"),(0,r.kt)("p",null,"Radicle basically uses Git as a database. This means everything is stored in a\nsingle Git monorepo that is read and written from via a Radicle client, like the CLI. Our\nGit implementation was devised to create an incentive for the seeder to provide\nall data necessary to resolve and verify a repository, while reducing latency by\neliminating gossip queries and git fetches as much as possible."),(0,r.kt)("p",null,"Read more about our approach ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/radicle-dev/radicle-link/blob/master/docs/rfc/0001-identity_resolution.md"},"here")),(0,r.kt)("h3",{id:"namespacing"},"Namespacing"),(0,r.kt)("p",null,"Radicle uses ",(0,r.kt)("a",{parentName:"p",href:"https://git-scm.com/docs/gitnamespaces"},"namespaces")," to store a ",(0,r.kt)("inlineCode",{parentName:"p"},"peer"),"'s Radicle data. By using\nnamespacing, Radicle Link partitions a single git repository - or monorepo -\ninto logical, smaller repos, that can be checked out individually. This monorepo\nincludes a ",(0,r.kt)("inlineCode",{parentName:"p"},"peer"),"'s identity (personal & project) data, as well as all tracked\nGit repositories."),(0,r.kt)("p",null,"The namespacing scheme has the following format:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"# Owner of the monorepo\nlet PEER_ID;\n\n# Peer tracked by $PEER_ID, either directly or transitively\nlet TRACKED_PEER_ID;\n\n# Identity hash of the project or peer\nlet IDENTITY;\n\n# Identity hashes of certifiers of $IDENTITY\nlet CERTIFIER[1..];\n\n$PEER_ID/refs/\n`-- namespaces\n    `-- $IDENTITY\n        `-- refs\n            |-- heads # <-- code branches owned by $PEER_ID go here\n            |-- rad\n            |   |-- id # <-- points to the identity document history\n            |   |-- signed_refs # <-- signed refs of the peer\n            |   |-- self # <-- points to the identity of $PEER_ID\n            |   `-- ids\n            |       |-- $CERTIFIER[1]\n            |       `-- $CERTIFIER[2]\n            `-- remotes\n                `-- $TRACKED_PEER_ID\n                    |-- heads\n                    `-- rad\n                        |-- id\n                        |-- signed_refs\n                        |-- self\n                        `-- ids\n                            |-- $CERTIFIER[1]\n                            `-- $CERTIFIER[2]\n")),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("strong",{parentName:"p"},"owned")," $CERTIFIER","[n]"," refs (ie. not those of remotes) are\n",(0,r.kt)("a",{parentName:"p",href:"https://git-scm.com/docs/git-symbolic-ref"},"symbolic refs"),", pointing to the ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/id")," branch of the respective\nnamespace. For example, if identity ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," is certified by identity ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"refs/namespaces/A/refs/rad/ids/B")," would contain:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ref: refs/namespaces/B/refs/rad/id\n")),(0,r.kt)("p",null,"The certifier can only certify if the certifying identity is present locally and\nis logically valid for the certifier to use for certifying. The symref ensures\nthat the certifying identity can be updated in one place, and stays up-to-date\nat all use sites without maintenance."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/self")," branch identifies ",(0,r.kt)("inlineCode",{parentName:"p"},"$PEER_ID"),", i.e. the ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/id")," branch of the\ncorresponding identity namespace. For example, if the identity of ",(0,r.kt)("inlineCode",{parentName:"p"},"$PEER_ID")," is\n",(0,r.kt)("inlineCode",{parentName:"p"},"C"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/self")," within the context of ",(0,r.kt)("inlineCode",{parentName:"p"},"$IDENTITY")," would be a symref:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ref: refs/namespaces/C/rad/id\n")),(0,r.kt)("p",null,"Any certifiers of the ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," identity must be included under ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/ids/"),". The\n",(0,r.kt)("inlineCode",{parentName:"p"},"rad/self")," branch contains the  equivalent to the contributor file in the\nradicle-link spec, rev1-draft, which is required iff the refs/heads/ hierarchy\nof $PEER_ID is non-empty (ie. it is permissible to omit it if $PEER_ID does not\npublish any branches of their own)."),(0,r.kt)("h3",{id:"git-encoding"},"Git Encoding"),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"git")," implementation, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Doc")," corresponds to a ",(0,r.kt)("inlineCode",{parentName:"p"},"blob")," object, stored as\nthe single entry of a ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," object, such that its name (acc. to the ",(0,r.kt)("inlineCode",{parentName:"p"},"tree"),") is\nequal to the ",(0,r.kt)("inlineCode",{parentName:"p"},"blob")," hash of the ",(0,r.kt)("em",{parentName:"p"},"initial")," version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Doc"),", serialised in\ncanonical form. That is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let name = git hash-object -t blob doc.canonical_form()\n")),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity")," corresponds to a ",(0,r.kt)("inlineCode",{parentName:"p"},"commit")," object."),(0,r.kt)("p",null,"We map the fields as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/* Simplified git object model */\nstruct Commit {\n    id: Oid,\n    tree: Tree,\n    message: String,\n}\n\nstruct Tree {\n    id: Oid,\n    entries: Vec<TreeEntry>,\n}\n\nstruct TreeEntry {\n    id: Oid,\n    name: String,\n    object: BlobOrTree,\n}\n\nstruct Blob {\n    id: Oid,\n    content: Vec<u8>,\n}\n\n/* Mapping (trivial type conversions elided) */\nlet commit = /* .. */;\nlet identity = Identity {\n    id: commit.id,\n    root: commit.tree.entries[0].name,\n    revision: tree.id,\n    doc: deserialize(first_blob(commit.tree).content),\n    signatures: from_trailers(commit.message),\n};\n")),(0,r.kt)("p",null,"Where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"first_blob")," finds the first ",(0,r.kt)("inlineCode",{parentName:"li"},"TreeEntry")," which is of type ",(0,r.kt)("inlineCode",{parentName:"li"},"blob"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deserialize")," is implemented by a standard JSON parser. ",(0,r.kt)("inlineCode",{parentName:"li"},"User")," delegations\nfrom a ",(0,r.kt)("inlineCode",{parentName:"li"},"Project")," are specified in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Project"),"'s ",(0,r.kt)("inlineCode",{parentName:"li"},"Doc")," as URNs, which are\nresolved by parsing a ",(0,r.kt)("inlineCode",{parentName:"li"},"blob")," object of the same name as the URN's ",(0,r.kt)("inlineCode",{parentName:"li"},"id")," field\nbelow the ",(0,r.kt)("inlineCode",{parentName:"li"},"tree")," entry of type directory named ",(0,r.kt)("inlineCode",{parentName:"li"},"delegations"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from_trailers")," interprets the commit message as per\n",(0,r.kt)("a",{parentName:"li",href:"https://git-scm.com/docs/git-interpret-trailers"},"git-interpret-trailers"),", and extracts the signatures from trailers with\nthe token ",(0,r.kt)("inlineCode",{parentName:"li"},"x-rad-signature"),".")),(0,r.kt)("p",null,"The commit chain is stored in a branch at ",(0,r.kt)("inlineCode",{parentName:"p"},"refs/rad/id")," in the peer's monorepo."),(0,r.kt)("h3",{id:"fetching"},"Fetching"),(0,r.kt)("p",null,"Fetching (or cloning) happens on a per-",(0,r.kt)("inlineCode",{parentName:"p"},"$IDENTITY")," basis, meaning when a peer\nfetches a project, they only have to fetch information from the peers they are\ninterested in. Due to the ",(0,r.kt)("a",{parentName:"p",href:"#namespacing"},"certifier symrefs"),', the peer being fetched from\nis able to advertise a "proof" (or perhaps better: "promise") to be able to\ninclude all relevant data (the ',(0,r.kt)("inlineCode",{parentName:"p"},"rad/id"),' branches) in the packfile. This enables,\nin a single packfile, a "mirror" of the logical remote repository requested, ',(0,r.kt)("em",{parentName:"p"},"as\nwell as")," all of the top-level logical repositories of all certifiers required to\nverify the identity document(s)."),(0,r.kt)("p",null,"See more on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/radicle-dev/radicle-link/blob/master/docs/rfc/0001-identity_resolution.md#fetching"},"Fetching")),(0,r.kt)("h3",{id:"working-copies"},"Working Copies"),(0,r.kt)("p",null,"Within the ",(0,r.kt)("inlineCode",{parentName:"p"},"rad"),' refs category, peers can obtain a working copy of a specific\nrepository that can hide "special" branches during to our namespacing scheme. We\ncall this ',(0,r.kt)("inlineCode",{parentName:"p"},"checking out"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'[remote "rad"]\n    url = file://path/to/monorepo.git\n    fetch = +refs/namespaces/$IDENTITY/refs/heads/*:refs/remotes/rad/refs/heads/*\n')),(0,r.kt)("p",null,"In addition to this, we can see the branches of tracked peers by running ",(0,r.kt)("inlineCode",{parentName:"p"},"git\nbranch"),". To provide a human-readable view of a project's remotes, when fetching\nwe inspect the ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/self")," identity metadata in order to find nicknames. This is managed entirely by ",(0,r.kt)("inlineCode",{parentName:"p"},"librad"),", which\nreduces to the following in the working copy's config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"[include]\n    path = /path/to/managed.inc\n")),(0,r.kt)("h2",{id:"peer-discovery--replication"},"Peer Discovery & Replication"),(0,r.kt)("h3",{id:"overview-3"},"Overview"),(0,r.kt)("p",null,"Radicle Link extends Git with peer-to-peer network discovery via a process\ncalled ",(0,r.kt)("strong",{parentName:"p"},"gossip"),'. This means that peers in the network share and spread data\nthey are "interested" in by keeping (replicating) redundant copies locally and\nsharing deltas with peers. With Radicle, we replicate data across connected\nrepositories according to a \u201csocial graph\u201d of peers and projects, enabling\nsource code and changesets to be disseminated according to use and value: the\nmore peers who are interested in a certain project, the more available this\nproject is made to the network.'),(0,r.kt)("h3",{id:"replication-model"},"Replication Model"),(0,r.kt)("p",null,"Repositories are the base unit of replication in Radicle. To publish a\nrepository to the network, it must first be initialized as a project. Project\ncombine source code, issues and proposed changes under a single umbrella, and\ncarry a unique, shareable peer-to-peer identifier. The entirety of the project\ndata and metadata, including social artefacts such as comments, are stored\nwithin the repository. To create a project, the owner of a repository defines a\nproject identity. In the background, a project identity document is created in a\npredetermined disjoint branch of the repository, by convention ",(0,r.kt)("inlineCode",{parentName:"p"},"rad/id"),". This\nfile contains important metadata such as the project name, list of maintainers,\nas well as any related links."),(0,r.kt)("p",null,"The unit of replication is a repository, identified by a ",(0,r.kt)("inlineCode",{parentName:"p"},"PeerID")," in the context\nof a project document (See ",(0,r.kt)("a",{parentName:"p",href:"#data-model"},"Data Model"),"). The holder of the corresponding\n",(0,r.kt)("inlineCode",{parentName:"p"},"DeviceKey")," is referred to as the ",(0,r.kt)("strong",{parentName:"p"},"maintainer")," of the repository. Repositories\nbelonging to the same project are represented locally as a single repository,\nidentified by a Radicle URN. In the\ncontext of a project, the maintainer of a repository may choose to track the\nrepositories of other peers (this is called a remote in git terminology: a named\nreference to a remote repository). If the remote repository is found to track\nother remotes, the tracking repository will also transitively track those, up to\nn hops out."),(0,r.kt)("p",null,"Therefore, a project on Radicle preserves the transitivity information of its\nremotes (i.e. via which tracked PeerID another PeerID is tracked)."),(0,r.kt)("h3",{id:"tracking"},"Tracking"),(0,r.kt)("p",null,"Tracking is the backbone of collaboration as it drives the exchange of projects\nand their artifacts. In Radicle, peers track other peers and projects that they\nare interested in. This happens when a peer clones another peer's project."),(0,r.kt)("p",null,"Since peers represent seperate devices in the network, they each have their own\nview of the network. Each peer tracks this view of projects, identities, and\ndata from connected peers in its own monorepo (See ",(0,r.kt)("a",{parentName:"p",href:"#git-implementation"},"Git Implementation"),")."),(0,r.kt)("p",null,"When a peer tracks another peer in the context of a project \u2014 say, if it clones\nanother peer's project \u2014 it sets the intention to fetch and gossip the other\npeer's view of that project. This means includes the project metadata, all\nworking branches and commits, and changesets will be replicated and stored in\nthe tracking peer's monorepo, so that it can be fetched and collaborated on."),(0,r.kt)("p",null,"Specifically, this means the tracked peer will be added as a ",(0,r.kt)("em",{parentName:"p"},"remote")," within the\ntracking peer's monorepo as a ",(0,r.kt)("inlineCode",{parentName:"p"},"$TRACKED_PEER_ID"),", as seen in the following\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"# Owner of the monorepo\nlet PEER_ID;\n\n# Peer tracked by $PEER_ID, either directly or transitively\nlet TRACKED_PEER_ID;\n\n# Identity hash of the project or user\nlet IDENTITY;\n\n# Identity hashes of certifiers of $IDENTITY\nlet CERTIFIER[1..];\n\n$PEER_ID/refs/\n`-- namespaces\n    `-- $IDENTITY\n        `-- refs\n            |-- heads # <-- code branches owned by $PEER_ID go here\n            |-- rad\n            |   |-- id # <-- points to the identity document history\n            |   |-- signed_refs # <-- signed refs of the peer\n            |   |-- self # <-- points to the identity of $PEER_ID\n            |   `-- ids\n            |       |-- $CERTIFIER[1]\n            |       `-- $CERTIFIER[2]\n            `-- remotes\n                `-- $TRACKED_PEER_ID\n                    |-- heads <-- code branches owned by $TRACKED_PEER_ID go here\n                    `-- rad\n                        |-- id\n                        |-- signed_refs\n                        |-- self <-- points to the identity of $TRACKED_PEER_ID\n                        `-- ids\n                            |-- $CERTIFIER[1]\n                            `-- $CERTIFIER[2]\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#namespacing"},"Namespacing")," for more on monorepo structure."),(0,r.kt)("p",null,"As well as being added to ",(0,r.kt)("inlineCode",{parentName:"p"},"remotes/$TRACKED_PEER_ID"),", the tracking peer's\nmonorepo will also gain an entry in its ",(0,r.kt)("inlineCode",{parentName:"p"},"config")," file (See ",(0,r.kt)("a",{parentName:"p",href:"#fetching"},"Fetching"),"). This\nmeans that if the tracked peer announces changes and they are gossiped to the\ntracking peer \u2014 whether through their device or another peer's \u2014 they can be\nfetched and applied to the tracking peer's monorepo."),(0,r.kt)("h4",{id:"direct-tracking"},"Direct Tracking"),(0,r.kt)("p",null,"The other way a peer can track another peer is by explicity telling their\nmonorepo to track a specific ",(0,r.kt)("inlineCode",{parentName:"p"},"PEER_ID"),". Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"track")," function with\n",(0,r.kt)("inlineCode",{parentName:"p"},"PEER_ID")," of interest, the monorepo creates a new entry in the git config. Any\nupdates from the tracked peer can be similarly fetched and applied the tracking\npeer's monorepo."),(0,r.kt)("h4",{id:"the-social-graph"},"The Social Graph"),(0,r.kt)("p",null,"In the case of multiple peer replications, any peer that tracks a project will\nimplicitly track it's maintainers as well. This means that when any peer on the\nnetwork clones a project, all of said project's maintainers will end up in that\npeer's remote list. Since maintainers of the project work on the canonical view\nof the project, this automatic tracking ensures the health and consistency of a\nproject as it's gossiped across the network."),(0,r.kt)("p",null,"This also means that for a single ",(0,r.kt)("inlineCode",{parentName:"p"},"PEER_ID"),", we have a sub-graph that consists\nof more ",(0,r.kt)("inlineCode",{parentName:"p"},"PEER_ID"),"s \u2014 whether they be the maintainers of the project or other\ntracked peers. Any time a peer is replicated, a portion of their sub-graph is\nreplicated as well, up to 2 hops out."),(0,r.kt)("p",null,"This means that everytime you track a peer, you are not only adding them as a\nremote, but also their remotes, and the remotes of their remotes. This ensures\nthat a project is consistently available across the network without a total\nreliance on the maintainers of the project or the original tracked peer."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"/img/socialgraph.png",alt:"Social Graph"})),(0,r.kt)("h3",{id:"validation"},"Validation"),(0,r.kt)("p",null,"To ensure data integrity and authenticity, when creating a working copy of a\nproject, the attestation history according to the remote peer is fetched before\nall other repository contents, and the verification procedure (See\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/radicle-dev/radicle-link/blob/master/docs/spec/identities.md#verification"},"Verification"),") is run on it. If this does not yield a verified status, the\nclone is aborted. The resulting repository state must include the attestation\nhistories of at least a quorum of the delegates (See ",(0,r.kt)("a",{parentName:"p",href:"#delegations"},"Delegation"),") as per\nthe remote peer's view of the identity document. In Git, the claim that this\nwill be the case can be determined before fetching the repository contents by\nexamining the advertised remote refs (See ",(0,r.kt)("a",{parentName:"p",href:"#fetching"},"Fetching"),"). If these\npreconditions are not met, the clone is aborted, and already fetched data is\npruned."),(0,r.kt)("h3",{id:"seeding"},"Seeding"),(0,r.kt)("p",null,"To improve data availability, participants in the network can choose to act as\nseeds. This is similar in concept to a pub in ",(0,r.kt)("a",{parentName:"p",href:"https://scuttlebutt.nz/"},"Secure Scuttlebutt"),'. Seed\nnodes are "always-on" nodes running on public IP addresses that serve data to\nany connected peers. By joining a seed node, it automatically tracks you and\nshares your data across its network of other connected users. This increases the\navailability of your data throughout the network, while making it easier to find\nother\'s data as well.'),(0,r.kt)("p",null,"A seed may track a large number of repositories for a given project, so cloning\nfrom a seed will greatly increase the connectedness of a tracking graph. Also\nnote that, by tracking a seed, upstream maintainers can increase the number of\npaths leading back to them, such that contributions can flow back up even if\nthey come from participants not within the set of tracked repositories of a\nmaintainer."),(0,r.kt)("h2",{id:"collaboration-model"},"Collaboration Model"),(0,r.kt)("p",null,"Our construction of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity")," from a git commit allows for multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),"s\nto describe the same revision of the document (and thus be equally valid). This\nmeans that the respective delegates' histories may diverge in their ",(0,r.kt)("em",{parentName:"p"},"commit"),"\nhistories, but still converge to an agreement on the validity of the attested\ndocument revision."),(0,r.kt)("p",null,"This means that there isn't a single canonical branch (or ",(0,r.kt)("inlineCode",{parentName:"p"},"master"),"),\nas peers are all maintaining their own upstreams of the same project. However,\ndue to the data model of Radicle identities, there will always be a 'canonical'\nview of a project associated with its ",(0,r.kt)("strong",{parentName:"p"},"maintainers"),". Maintainers can follow a\nleader-based workflow in which they are converging histories of contributing\npeers into their main branch. Since their view is verifiable and implicitly\ntracked whenever a peer follows a project, peers can ensure they are replicating\na canonical and updated view of a project."),(0,r.kt)("p",null,"In addition to this, the way Radicle Link works introduces certain implications\nfor end-user collaboration experience:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Your social graph determines what type of content you see, interact with and\nreplicate."))),(0,r.kt)("p",null,"Assuming you have discovered a project of interest within the Radicle network\n(more on discoverability later), then the first thing you have to do in order to\ninteract with it is to track it. Tracking a project signals interest, and by\ndesign implies tracking the project's maintainers, therefore replicating the\ndata within their social graphs."),(0,r.kt)("p",null,"In the context of a project, maintainers of a repository may choose to track the\nviews of other owners (this is called a remote in Git terminology: a named\nreference to a remote repository). If the remote repository is found to track\nother remotes, the tracking repository shall also transitively track those, up\nto a configurable N hops out (currently in the works)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spam and content moderation is naturally handled by the peer's social\ngraph"))),(0,r.kt)("p",null,"While this might appear confusing at first, in fact its far more natural (it\nactually mimics real life communication) and by design addresses issues like\nspam and content moderation, which are naturally handled by the peer's social\ngraph."),(0,r.kt)("p",null,"A spammer's patches or issues will never be tracked by the actual maintainers\nand as a result they wont be seen by the rest of the network (unless explicitly\ntracked). Similarly, if you are not interested in a peer's views or\ncontributions to a project, you can simply un-follow them, stopping to\nreplicate, view and interact with their data."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Within the same project, two peers might have diverging views."))),(0,r.kt)("p",null,"The above design also means that even within the same project, peers have\nsubjective (and often diverging) views."),(0,r.kt)("p",null,"At minimum, your view of a project becomes the sum of the views of the people\nyou follow, plus the views of the maintainers of the project. In addition, you\ncan expand your perspective by configuring your replication settings to also\ntransitively track other remotes N hops out from the peers you follow (i.e.\npeers of your peers / remotes of your remotes)."),(0,r.kt)("p",null,'This design also addresses a significant problem with decentralized systems\nrelying exclusively on distributed ledger technology, the problem of "blockchain\npoisoning". This is when someone deliberately adds illegal content to an append\nonly source in hopes to make the sole act of replicating the project legally\nproblematic, as correctly pointed out by Konstantin Ryabitsev of the Linux\nfoundation with regards to a ',(0,r.kt)("a",{parentName:"p",href:"http://alpha.radicle.xyz"},"previous version")," of\nRadicle that was relying on ",(0,r.kt)("a",{parentName:"p",href:"https://ipfs.io/"},"IPFS"),"."),(0,r.kt)("p",null,"Read more about the ",(0,r.kt)("a",{parentName:"p",href:"https://radicle.community/t/the-radicle-social-model/317"},"Radicle collaboration model"),"."))}m.isMDXComponent=!0}}]);